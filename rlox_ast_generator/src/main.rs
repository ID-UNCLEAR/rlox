use std::env::Args;
use std::path::{Path, PathBuf};
use std::process::{Command, ExitStatus};
use std::{env, fs};

fn main() {
    let output_directory: String = get_path_argument();
    let output_path: PathBuf = generate_ast(
        &output_directory,
        "Expr",
        &[
            "Binary   : left: Box<Expr>, operator: Token, right: Box<Expr>",
            "Grouping : expression: Box<Expr>",
            "Literal  : value: Literal",
            "Unary    : operator: Token, right: Box<Expr>",
        ],
    );
    format_ast(&output_path);
}

fn get_path_argument() -> String {
    let mut args: Args = env::args();
    while let Some(arg) = args.next() {
        if arg == "--path" {
            return args
                .next()
                .expect("No value provided for `--path` argument!");
        }
    }

    // Default path
    String::from("../rlox_ast/src")
}

fn generate_ast(output_dir: &str, base_name: &str, types: &[&str]) -> PathBuf {
    let path: PathBuf = Path::new(output_dir).join(format!("{}.rs", base_name.to_lowercase()));
    let mut code: String = String::new();

    code.push_str("// This file is automatically generated. Do not edit manually.\n");
    code.push_str("// Consider rerunning the rlox_ast_generator for changes.\n\n");
    code.push_str("use common::token::{Literal, Token};\n\n");
    code.push_str(&format!("#[derive(Debug)]\npub enum {} {{\n", base_name));

    for t in types {
        if let Some((name, fields)) = t.split_once(':') {
            code.push_str(&format!("    {} {{ {} }},\n", name.trim(), fields.trim()));
        } else {
            eprintln!("Skipping malformed type definition: {}", t);
        }
    }

    code.push_str("}\n");

    fs::create_dir_all(output_dir).expect("Failed to create output directory");
    fs::write(&path, code).expect("Failed to write code to output file");

    println!("Generated AST at: {}", path.display());
    path
}

fn format_ast(file_path: &Path) {
    let status: ExitStatus = Command::new("rustfmt")
        .arg(file_path)
        .status()
        .expect("Failed to run `rustfmt`. Is it installed?");

    if !status.success() {
        eprintln!("`rustfmt` failed with status: {}", status);
    } else {
        println!("Formatted generated AST at: {}", file_path.display());
    }
}
